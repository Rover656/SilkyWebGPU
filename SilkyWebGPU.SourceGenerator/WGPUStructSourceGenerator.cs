using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Rover656.SilkyWebGPU.SourceGenerator
{
    // TODO: This does quite well already. Will want to tap into the NativeType annotations to grab more data.
    //       We want to atleast fix enums. The rest I'm happy to be manually controlled with partial classes.

    /// <summary>
    /// Source generator for generating friendly struct wrappers.
    /// </summary>
    [Generator]
    public class WGPUStructSourceGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            foreach (var structName in Constants.ManagedStructs)
            {
                var structSymbol = context.Compilation.GetTypeByMetadataName($"{Constants.WebGpuNS}.{structName}");
                if (structSymbol == null)
                    continue;

                var structFriendlyName = structName.Split('.').Last();
                // var structExtraNamespace = "";
                // if (structName.Contains("."))
                // {
                //     structExtraNamespace = "." + structName.Remove(
                //         structName.Length - structFriendlyName.Length - 1,
                //         structFriendlyName.Length + 1);
                // }

                var outputWriter = new StringBuilder($@"// <auto-generated/>

using {Constants.ExtensionNS};
using {Constants.ExtensionNS}.Native;
using {Constants.ExtensionNS}.Native.Chain;

using Silk.NET.Core.Native;
using Silk.NET.WebGPU;
using Silk.NET.WebGPU.Extensions.WGPU;

namespace {Constants.ExtensionNS};
");
                // Get type members
                var members = structSymbol.GetMembers();

                // Determine base class
                var baseClass = IsChainable(members)
                    ? Constants.ChainedStructBaseClass
                    : Constants.WrappedStructBaseClass;

                outputWriter.Append($@"
/// <seealso cref=""{Constants.WebGpuNS}.{structName}""/>
public sealed unsafe class {Constants.ManagedStructPrefix}{structFriendlyName} : {baseClass}<{Constants.WebGpuNS}.{structName}>
{{
");

                // Add implicit conversion for wrapped structs
                var chainable = IsChainable(members);
                var accessor = "->";
                if (!chainable)
                {
                    accessor = ".";
                    outputWriter.Append(
                        $@"    public {Constants.ManagedStructPrefix}{structFriendlyName}() : base() {{ }}
    public {Constants.ManagedStructPrefix}{structFriendlyName}({Constants.WebGpuNS}.{structName} native) : base(native) {{ }}

    public static implicit operator {Constants.ManagedStructPrefix}{structFriendlyName}({Constants.WebGpuNS}.{structName} native)
        => new {Constants.ManagedStructPrefix}{structFriendlyName}(native);
");
                }
                else
                {
                    outputWriter.Append(
                        $@"    public static implicit operator {Constants.WebGpuNS}.{structName}({Constants.ManagedStructPrefix}{structFriendlyName} managed)
        => managed != null ? managed.Get() : default;

    public static implicit operator Span<{Constants.WebGpuNS}.{structName}>({Constants.ManagedStructPrefix}{structFriendlyName} managed)
        => managed != null ? managed.GetRef() : default;
");
                }

                // Get fields
                var managedDispose = new List<string>(); // private fields that need disposing.
                var marshalFree = new List<string>(); // native memory to free
                foreach (var member in members)
                {
                    if (member is IFieldSymbol field)
                    {
                        // Skip anything to do with the chain.
                        if (field.Name == "Chain" || field.Name == "NextInChain")
                            continue;

                        // Skip this if this is an array counter.
                        if (IsArrayCounter(members, field))
                            continue;

                        // TODO: Enum arrays and pointer arrays.
                        // PipelineStatistics is a false positive of a single pointer value.

                        if (field.Type.Kind != SymbolKind.PointerType)
                        {
                            if (Constants.ChainedStructs.Contains(field.Type.Name))
                            {
                                outputWriter.Append($@"
    // Keep the pointer alive :D
    private {Constants.ManagedStructPrefix}{field.Type.Name} _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {Constants.ManagedStructPrefix}{field.Type.Name} {field.Name}
    {{
        get => _{field.Name};

        set
        {{
            // Dispose existing
            _{field.Name}?.Dispose();
            
            // Store managed version
            _{field.Name} = value;

            // Set within chain.
            if (value != null)
                Native{accessor}{field.Name} = value.Get();
            else Native{accessor}{field.Name} = default;
        }}
    }}
 ");
                                // Setup for freeing resources
                                managedDispose.Add(field.Name);
                            }
                            else if (Constants.WrappedStructs.Contains(field.Type.Name))
                            {
                                outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {Constants.ManagedStructPrefix}{field.Type.Name} {field.Name}
    {{
        get => Native{accessor}{field.Name};
        set => Native{accessor}{field.Name} = value;
    }}
 ");
                            }
                            else
                            {
                                outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {field.Type} {field.Name}
    {{
        get => Native{accessor}{field.Name};
        set => Native{accessor}{field.Name} = value;
    }}
 ");
                            }
                        }
                        else
                        {
                            var pointerType = field.Type as IPointerTypeSymbol;

                            // Check if this is a pointer array.
                            if (IsArrayField(members, field, out var arrayCountField, out var arrayCountType))
                            {
                                if (pointerType.PointedAtType is IPointerTypeSymbol pointedAtType)
                                {
                                    outputWriter.Append($@"
    // Keep a copy around for disposal.
    private {Constants.NativePointerArrayType}<{pointedAtType.PointedAtType}> _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    /// <remarks>
    /// TODO: Write this remark.
    /// Summary: Will update if you modify the existing pointer, but if you replace it, it won't.
    /// </remarks>
    public {Constants.NativePointerArrayType}<{pointedAtType.PointedAtType}> {field.Name}
    {{
        // Return a readonly weak copy.
        get => new {Constants.NativePointerArrayType}<{pointedAtType.PointedAtType}>((int) Native{accessor}{arrayCountField}, Native{accessor}{field.Name});

        set
        {{
            // Dispose any existing object.
            _{field.Name}?.Dispose();

            // Set array
            if (value != null)
            {{
                Native{accessor}{field.Name} = value.Ptr;
                Native{accessor}{arrayCountField} = ({arrayCountType}) value.Count;
            }}
            else
            {{
                Native{accessor}{field.Name} = null;
                Native{accessor}{arrayCountField} = 0;
            }}

            // Save for later disposal
            _{field.Name} = value;
        }}
    }}
 ");
                                }
                                else
                                {
                                    outputWriter.Append($@"
    // Keep a copy around for disposal.
    private {Constants.NativeChainableArrayType}<{pointerType.PointedAtType}> _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    /// <remarks>
    /// TODO: Write this remark.
    /// Summary: Will update if you modify the existing pointer, but if you replace it, it won't.
    /// </remarks>
    public {Constants.NativeChainableArrayType}<{pointerType.PointedAtType}> {field.Name}
    {{
        // Return a readonly weak copy.
        get => new {Constants.NativeChainableArrayType}<{pointerType.PointedAtType}>((int) Native{accessor}{arrayCountField}, Native{accessor}{field.Name});

        set
        {{
            // Dispose any existing object.
            _{field.Name}?.Dispose();

            // Set array
            if (value != null)
            {{
                Native{accessor}{field.Name} = value.Ptr;
                Native{accessor}{arrayCountField} = ({arrayCountType}) value.Count;
            }}
            else
            {{
                Native{accessor}{field.Name} = null;
                Native{accessor}{arrayCountField} = 0;
            }}

            // Save for later disposal
            _{field.Name} = value;
        }}
    }}
 ");
                                    managedDispose.Add(field.Name);
                                }
                            }
                            else
                            {
                                if (Constants.ClassObjects.Contains(pointerType.PointedAtType.Name))
                                {
                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {Constants.NativePtrType}<{pointerType.PointedAtType}> {field.Name}
    {{
        get => {Constants.NativePtrType}<{pointerType.PointedAtType}>.Weak(Native{accessor}{field.Name});
        set => Native{accessor}{field.Name} = value;
    }}
 ");
                                }
                                else if (Constants.ChainedStructs.Contains(pointerType.PointedAtType.Name))
                                {
                                    outputWriter.Append($@"
    // Keep the pointer alive :D
    private {Constants.ManagedStructPrefix}{pointerType.PointedAtType.Name} _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {Constants.ManagedStructPrefix}{pointerType.PointedAtType.Name} {field.Name}
    {{
        get => _{field.Name};
        set
        {{
            // Dispose existing
            _{field.Name}?.Dispose();
            
            // Store managed version
            _{field.Name} = value;

            // Set within chain.
            if (value != null)
                Native{accessor}{field.Name} = ({pointerType.PointedAtType}*) value.GetPtr();
            else Native{accessor}{field.Name} = null;
        }}
    }}
 ");

                                    // Add free list
                                    marshalFree.Add(field.Name);
                                }
                                else if (pointerType.PointedAtType.Name == "Byte")
                                {
                                    // This is a *string*
                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public string {field.Name}
    {{
        get => SilkMarshal.PtrToString((nint) Native{accessor}{field.Name});
        set
        {{
           if (Native->{field.Name} != null)
               SilkMarshal.Free((nint) Native{accessor}{field.Name});
           Native{accessor}{field.Name} = (byte *) SilkMarshal.StringToPtr(value);
        }}
    }}
 ");

                                    // Remember to free this with the marshal!
                                    marshalFree.Add(field.Name);
                                }
                                else if (pointerType.PointedAtType.Name == "Void")
                                {
                                    outputWriter.Append($@"
    /// <summary>
    /// This is a currently unsupported type.
    /// Native type: {field.Type}.
    /// Original name: {field.Name}.
    /// Is array type?: false.
    /// </summary>
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {field.Type} {field.Name}
    {{
        get => Native{accessor}{field.Name};
        set => Native{accessor}{field.Name} = value;
    }}
");
                                }
                                else if (pointerType.PointedAtType.Kind != SymbolKind.PointerType)
                                {
                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {pointerType.PointedAtType}? {field.Name}
    {{
        get
        {{
            if (Native{accessor}{field.Name} == null)
                return null;
            return *Native{accessor}{field.Name};
        }}

        set
        {{
            // If we're setting this to null, wipe the memory.
            if (!value.HasValue)
            {{
                SilkMarshal.Free((nint) Native{accessor}{field.Name});
                Native{accessor}{field.Name} = null;
                return;
            }}

            // Because we will always own this handle, we allocate if its null, or we overwrite data.
            if (Native{accessor}{field.Name} == null)
                Native{accessor}{field.Name} = ({pointerType.PointedAtType}*) SilkMarshal.Allocate(sizeof({pointerType.PointedAtType}));

            // Write new data
            *Native{accessor}{field.Name} = value.Value;
        }}
    }}
 ");

                                    marshalFree.Add(field.Name);
                                }
                                else
                                {
                                    outputWriter.Append($@"
    /// <summary>
    /// This is a currently unsupported type.
    /// Native type: {field.Type}.
    /// Original name: {field.Name}.
    /// Is array type?: false.
    /// </summary>
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {field.Type} {field.Name}
    {{
        get => Native{accessor}{field.Name};
        set => Native{accessor}{field.Name} = value;
    }}
");
                                }
                            }
                        }
                    }
                }

                outputWriter.AppendLine($@"
    public override string ToString()
    {{
        // Write anything to the console we deem writable. This might not be accurate but its good enough for debug purposes :)
        return $@""{structFriendlyName} {{{{");

                // Write a ToString method for debugging
                foreach (var member in structSymbol.GetMembers())
                {
                    // Ignore non-members
                    if (!(member is IFieldSymbol field))
                        continue;

                    // Skip anything to do with the chain.
                    if (field.Name == "Chain" || field.Name == "NextInChain")
                        continue;

                    // Skip certain pointers
                    if (field.Type is IPointerTypeSymbol pointerField)
                    {
                        if (!Constants.ManagedStructs.Contains(pointerField.PointedAtType.Name) &&
                            pointerField.PointedAtType.Name != "Byte")
                            continue;
                    }

                    // Skip arrays
                    if (IsArrayCounter(members, field) || IsArrayField(members, field, out _, out _))
                        continue;

                    // Add to ToString output.
                    outputWriter.AppendLine($"    {field.Name} = \"\"{{{field.Name}}}\"\"");
                }

                outputWriter.AppendLine(@"}}"";
    }");

                // Dispose method
                outputWriter.AppendLine(@"
    protected override void Dispose(bool disposing)
    {
        if (Disposed) return;");
                
                if (managedDispose.Count > 0)
                {
                    outputWriter.AppendLine(@"        if (disposing)
        {");
                    
                    // Chain frees
                    foreach (var fieldName in managedDispose)
                    {
                        outputWriter.AppendLine($@"            _{fieldName}?.Dispose();
            _{fieldName} = null;");
                    }
                    
                    outputWriter.AppendLine(@"        }
");
                }

                if (marshalFree.Count > 0)
                {
                    // Marshal frees
                    foreach (var fieldName in marshalFree)
                    {
                        outputWriter.AppendLine($@"        SilkMarshal.Free((nint) Native{accessor}{fieldName});
        Native{accessor}{fieldName} = null;");
                    }
                }
                
                outputWriter.AppendLine(@"        base.Dispose(disposing);
    }");

                outputWriter.AppendLine("}");

                context.AddSource($"{structFriendlyName}.generated.cs", outputWriter.ToString());
            }
        }

        private bool IsChainable(ImmutableArray<ISymbol> members)
        {
            foreach (var searchMember in members)
            {
                if (searchMember is IFieldSymbol searchField)
                {
                    if (searchField.Name == "NextInChain" || searchField.Name == "Chain")
                        return true;
                }
            }

            return false;
        }

        // Really garbage but for now should suffice.
        private bool IsArrayCounter(ImmutableArray<ISymbol> members, IFieldSymbol field)
        {
            if (!field.Name.Contains("Count"))
                return false;
            foreach (var searchMember in members)
            {
                if (searchMember is IFieldSymbol searchField)
                {
                    if (searchField.Name == $"{field.Name.Replace("Count", "")}")
                    {
                        return true;
                    }

                    // TODO: Should probably only replace last, but it'll do for now.
                    if (searchField.Name == $"{field.Name.Replace("Count", "")}s")
                    {
                        return true;
                    }

                    if (searchField.Name == $"{field.Name.Replace("Count", "").TrimEnd('y')}ies")
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsArrayField(ImmutableArray<ISymbol> members, IFieldSymbol field, out string countFieldName,
            out string countFieldType)
        {
            foreach (var searchMember in members)
            {
                if (searchMember is IFieldSymbol searchField)
                {
                    if (searchField.Name == field.Name + "Count")
                    {
                        countFieldName = field.Name + "Count";
                        countFieldType = searchField.Type.Name;
                        return true;
                    }

                    if (searchField.Name == field.Name.TrimEnd('s') + "Count")
                    {
                        countFieldName = field.Name.TrimEnd('s') + "Count";
                        countFieldType = searchField.Type.Name;
                        return true;
                    }

                    if (searchField.Name == field.Name.Replace("ies", "y") + "Count")
                    {
                        countFieldName = field.Name.Replace("ies", "y") + "Count";
                        countFieldType = searchField.Type.Name;
                        return true;
                    }
                }
            }

            countFieldName = "";
            countFieldType = "";
            return false;
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Do Nothing.
        }
    }
}