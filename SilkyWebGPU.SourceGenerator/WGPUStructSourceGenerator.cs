using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Rover656.SilkyWebGPU.SourceGenerators
{
    // TODO: This does quite well already. Will want to tap into the NativeType annotations to grab more data.
    //       We want to atleast fix enums. The rest I'm happy to be manually controlled with partial classes.

    /// <summary>
    /// Source generator for generating friendly struct wrappers.
    /// </summary>
    [Generator]
    public class WGPUStructSourceGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            foreach (var structName in Constants.ChainedStructs.Concat(Constants.WrappedStructs))
            {
                var structSymbol = context.Compilation.GetTypeByMetadataName($"{Constants.WebGpuNS}.{structName}");
                if (structSymbol == null)
                    continue;

                var structFriendlyName = structName.Split('.').Last();
                // var structExtraNamespace = "";
                // if (structName.Contains("."))
                // {
                //     structExtraNamespace = "." + structName.Remove(
                //         structName.Length - structFriendlyName.Length - 1,
                //         structFriendlyName.Length + 1);
                // }

                var outputWriter = new StringBuilder($@"// <auto-generated/>

using {Constants.ExtensionNS};
using {Constants.ExtensionNS}.Native;
using {Constants.ExtensionNS}.Native.Chain;

using Silk.NET.Core.Native;
using Silk.NET.WebGPU;
using Silk.NET.WebGPU.Extensions.WGPU;

namespace {Constants.ExtensionNS};
");
                // Get type members
                var members = structSymbol.GetMembers();
                
                // DEBUG
                var chainable = IsChainable(members);
                if (chainable && !Constants.ChainedStructs.Contains(structName))
                {
                    Console.WriteLine($"{structFriendlyName} is in the wrong struct array. It should be chained");
                }
                else if (!chainable && !Constants.WrappedStructs.Contains(structName))
                {
                    Console.WriteLine($"{structFriendlyName} is in the wrong struct array. It should be standard wrapped/");
                }
                
                // Determine base class
                var baseClass = IsChainable(members) ? Constants.ChainedStructBaseClass : "WrappedStruct";

                outputWriter.Append($@"
/// <seealso cref=""{Constants.WebGpuNS}.{structName}""/>
public class {Constants.ManagedStructPrefix}{structFriendlyName} : {baseClass}<{Constants.WebGpuNS}.{structName}>
{{
");
                
                // Add implicit conversion for wrapped structs
                if (!chainable)
                {
                    outputWriter.Append(
                        $@"    public static implicit operator {Constants.ManagedStructPrefix}{structFriendlyName}({Constants.WebGpuNS}.{structName} native) {{
        var ret = new {Constants.ManagedStructPrefix}{structFriendlyName}();
        ret.Native = native;
        return ret;
    }}
");
                }

                // Get fields
                var managedDispose = new List<string>(); // private fields that need disposing.
                var chainFreePtr = new List<string>(); // chained structs to free (alloc'd)
                var chainFreeRef = new List<string>(); // chained structs to free (getwithchain)
                var marshalFree = new List<string>(); // native memory to free
                foreach (var member in members)
                {
                    if (member is IFieldSymbol field)
                    {
                        // Skip anything to do with the chain.
                        if (field.Name == "Chain" || field.Name == "NextInChain")
                            continue;

                        // Skip this if this is an array counter.
                        if (IsArrayCounter(members, field))
                            continue;

                        // TODO: Enum arrays and pointer arrays.
                        // PipelineStatistics is a false positive of a single pointer value.

                        if (field.Type.Kind != SymbolKind.PointerType)
                        {
                            if (Constants.ChainedStructs.Contains(field.Type.Name))
                            {
                                outputWriter.Append($@"
    // Keep a copy around for disposal.
    private {Constants.ManagedStructPrefix}{field.Type.Name} _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    /// <remarks>
    /// Using this setter will take ownership of the provided object and will copy its data by value.
    /// This means you can no longer modify the contents of the object and have them update as a part of this one.
    /// This also means, when this object is disposed (or when you replace the value of this property with another value), the old value will be disposed.
    /// This is to ensure disposal occurs at the right time.
    /// </remarks>
    public unsafe {Constants.ManagedStructPrefix}{field.Type.Name} {field.Name}
    {{
        // TODO: Due to limitations, these are only writeable for now... Use the Raw field instead for reading.
        //get => Native.{field.Name};

        set
        {{
            // Dispose any existing object.
            _{field.Name}?.Dispose();

            // Attempt to free any existing chains
            ChainHelper.FreeChain(ref Native.{field.Name});

            // Allocate new chain -OR- set to default
            if (value != null)
                Native.{field.Name} = value.GetWithChain();
            else Native.{field.Name} = default;

            // Save
            _{field.Name} = value;
        }}
    }}
 ");
                                // Setup for freeing resources
                                managedDispose.Add(field.Name);
                                chainFreeRef.Add(field.Name);
                            }
                            else if (Constants.WrappedStructs.Contains(field.Type.Name))
                            {
                                outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {Constants.ManagedStructPrefix}{field.Type.Name} {field.Name}
    {{
        get => Native.{field.Name};
        set => Native.{field.Name} = value;
    }}
 ");
                            }
                            else
                            {
                                outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public {field.Type} {field.Name}
    {{
        get => Native.{field.Name};
        set => Native.{field.Name} = value;
    }}
 ");
                            }
                        }
                        else
                        {
                            var pointerType = field.Type as IPointerTypeSymbol;

                            // Check if this is a pointer array.
                            if (IsArrayField(members, field, out var arrayCountField))
                            {
                                if (pointerType.PointedAtType is IPointerTypeSymbol pointedAtType)
                                {
                                    outputWriter.Append($@"
    // Keep a copy around for disposal.
    private {Constants.NativePointerArrayType}<{pointedAtType.PointedAtType}> _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    /// <remarks>
    /// TODO: Write this remark.
    /// Summary: Will update if you modify the existing pointer, but if you replace it, it won't.
    /// </remarks>
    public unsafe {Constants.NativePointerArrayType}<{pointedAtType.PointedAtType}> {field.Name}
    {{
        // Return a readonly weak copy.
        get => new {Constants.NativePointerArrayType}<{pointedAtType.PointedAtType}>((uint) Native.{arrayCountField}, Native.{field.Name});

        set
        {{
            // Dispose any existing object.
            _{field.Name}?.Dispose();

            // Allocate new chain -OR- set to default
            if (value != null)
            {{
                Native.{field.Name} = value.Ptr;
                Native.{arrayCountField} = value.Count;
            }}
            else
            {{
                Native.{field.Name} = null;
                Native.{arrayCountField} = 0;
            }}

            // Save for later disposal
            _{field.Name} = value;
        }}
    }}
 ");
                                }
                                else
                                {
                                    outputWriter.Append($@"
    // Keep a copy around for disposal.
    private {Constants.NativeChainableArrayType}<{pointerType.PointedAtType}> _{field.Name};

    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    /// <remarks>
    /// TODO: Write this remark.
    /// Summary: Will update if you modify the existing pointer, but if you replace it, it won't.
    /// </remarks>
    public unsafe {Constants.NativeChainableArrayType}<{pointerType.PointedAtType}> {field.Name}
    {{
        // Return a readonly weak copy.
        get => new {Constants.NativeChainableArrayType}<{pointerType.PointedAtType}>((uint) Native.{arrayCountField}, Native.{field.Name});

        set
        {{
            // Dispose any existing object.
            _{field.Name}?.Dispose();

            // Allocate new chain -OR- set to default
            if (value != null)
            {{
                Native.{field.Name} = value.Ptr;
                Native.{arrayCountField} = value.Count;
            }}
            else
            {{
                Native.{field.Name} = null;
                Native.{arrayCountField} = 0;
            }}

            // Save for later disposal
            _{field.Name} = value;
        }}
    }}
 ");
                                    managedDispose.Add(field.Name);
                                }
                            }
                            else
                            {
                                if (Constants.ClassObjects.Contains(pointerType.PointedAtType.Name))
                                {
                                    // We ball
                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public unsafe {Constants.NativePtrType}<{pointerType.PointedAtType}> {field.Name}
    {{
        get => {Constants.NativePtrType}<{pointerType.PointedAtType}>.Weak(Native.{field.Name});
        set => Native.{field.Name} = value;
    }}
 ");
                                }
                                else if (Constants.ChainedStructs.Contains(pointerType.PointedAtType.Name))
                                {
                                    outputWriter.Append($@"
    /// <summary>
    /// This is raw access to the underlying field at its native type. This will likely be removed.
    /// <summary/>
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public unsafe {field.Type} {field.Name}Raw
    {{
        get => Native.{field.Name};
        set => Native.{field.Name} = value;
    }}
 ");

                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    /// <remarks>While this property is a reference type, this property will set by value.</remarks>
    public unsafe {Constants.ManagedStructPrefix}{pointerType.PointedAtType.Name} {field.Name}
    {{
        // TODO: Due to limitations, these are only writeable for now... Use the Raw field instead for reading.
        //get => Native.{field.Name};

        set
        {{
            // Release any existing native pointer.
            if (Native.{field.Name} != null)
            {{
                ChainHelper.FreeChain((ChainedStruct*) Native.{field.Name});
                SilkMarshal.Free((nint) Native.{field.Name});
            }}

            // Allocate new!
            if (value != null)
                Native.{field.Name} = value.Alloc();
            else Native.{field.Name} = null;
        }}
    }}
 ");

                                    // Add to both the marshal and chain free list
                                    chainFreePtr.Add(field.Name);
                                    marshalFree.Add(field.Name);
                                }
                                else if (pointerType.PointedAtType.Name == "Byte")
                                {
                                    // This is a *string*
                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public unsafe string {field.Name}
    {{
        get => SilkMarshal.PtrToString((nint) Native.{field.Name});

        set
       {{
           if (Native.{field.Name} != null)
               SilkMarshal.Free((nint) Native.{field.Name});
           Native.{field.Name} = (byte *) SilkMarshal.StringToPtr(value);
        }}
    }}
 ");

                                    // Remember to free this with the marshal!
                                    marshalFree.Add(field.Name);
                                }
                                else if (pointerType.PointedAtType.Name == "Void")
                                {
                                    outputWriter.Append($@"
    /// <summary>
    /// This is a currently unsupported type.
    /// Native type: {field.Type}.
    /// Original name: {field.Name}.
    /// Is array type?: false.
    /// </summary>
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public unsafe {field.Type} {field.Name}
    {{
        get => Native.{field.Name};
        set => Native.{field.Name} = value;
    }}
");
                                }
                                else if (pointerType.PointedAtType.Kind != SymbolKind.PointerType)
                                {
                                    outputWriter.Append($@"
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public unsafe {pointerType.PointedAtType}? {field.Name}
    {{
        get
        {{
            if (Native.{field.Name} == null)
                return null;
            return *Native.{field.Name};
        }}

        set
        {{
            // If we're setting this to null, wipe the memory.
            if (!value.HasValue)
            {{
                SilkMarshal.Free((nint) Native.{field.Name});
                Native.{field.Name} = null;
                return;
            }}

            // Because we will always own this handle, we allocate if its null, or we overwrite data.
            if (Native.{field.Name} == null)
                Native.{field.Name} = ({pointerType.PointedAtType}*) SilkMarshal.Allocate(sizeof({pointerType.PointedAtType}));

            // Write new data
            *Native.{field.Name} = value.Value;
        }}
    }}
 ");

                                    marshalFree.Add(field.Name);
                                }
                                else
                                {
                                    outputWriter.Append($@"
    /// <summary>
    /// This is a currently unsupported type.
    /// Native type: {field.Type}.
    /// Original name: {field.Name}.
    /// Is array type?: false.
    /// </summary>
    /// <seealso cref=""{Constants.WebGpuNS}.{structName}.{field.Name}"" />
    public unsafe {field.Type} {field.Name}
    {{
        get => Native.{field.Name};
        set => Native.{field.Name} = value;
    }}
");
                                }
                            }
                        }
                    }
                }

                outputWriter.AppendLine($@"
    public override unsafe string ToString()
    {{
        // Write anything to the console we deem writable. This might not be accurate but its good enough for debug purposes :)
        return $@""{structFriendlyName} {{{{");

                // Write a ToString method for debugging
                foreach (var member in structSymbol.GetMembers())
                {
                    // Ignore non-members
                    if (!(member is IFieldSymbol field))
                        continue;

                    // Skip anything to do with the chain.
                    if (field.Name == "Chain" || field.Name == "NextInChain" ||
                        chainFreeRef.Contains(field.Name) || chainFreePtr.Contains(field.Name))
                        continue;
                    
                    // Skip certain pointers
                    if (field.Type is IPointerTypeSymbol pointerField)
                    {
                        if (!Constants.ManagedStructs.Contains(pointerField.PointedAtType.Name) &&
                            pointerField.PointedAtType.Name != "Byte")
                            continue;
                    }
                    
                    // Skip arrays
                    if (IsArrayCounter(members, field) || IsArrayField(members, field, out _))
                        continue;

                    // Add to ToString output.
                    outputWriter.AppendLine($"    {field.Name} = \"\"{{{field.Name}}}\"\"");
                }

                outputWriter.AppendLine(@"}}"";
    }");

                // Dispose method
                if (managedDispose.Count > 0)
                {
                    outputWriter.AppendLine(@"
    public override unsafe void Dispose()
    {");
                    // Chain frees
                    foreach (var fieldName in managedDispose)
                    {
                        outputWriter.AppendLine($@"        _{fieldName}?.Dispose();
        _{fieldName} = null;");
                    }

                    outputWriter.AppendLine(@"        base.Dispose();
    }");
                }

                if (chainFreeRef.Count > 0 || chainFreePtr.Count > 0 || marshalFree.Count > 0)
                {
                    outputWriter.AppendLine(@"
    protected override unsafe void ReleaseUnmanagedResources()
    {");
                    // Chain frees
                    foreach (var fieldName in chainFreeRef)
                    {
                        outputWriter.AppendLine($"        ChainHelper.FreeChain(ref Native.{fieldName});");
                    }

                    foreach (var fieldName in chainFreePtr)
                    {
                        outputWriter.AppendLine($@"        ChainHelper.FreeChain((ChainedStruct*) Native.{fieldName});
        Native.{fieldName} = null;");
                    }

                    // Marshal frees
                    foreach (var fieldName in marshalFree)
                    {
                        outputWriter.AppendLine($@"        SilkMarshal.Free((nint) Native.{fieldName});
        Native.{fieldName} = null;");
                    }

                    outputWriter.AppendLine(@"    }");
                }

                outputWriter.AppendLine("}");

                context.AddSource($"{structFriendlyName}.generated.cs", outputWriter.ToString());
            }
        }

        private bool IsChainable(ImmutableArray<ISymbol> members)
        {
            foreach (var searchMember in members)
            {
                if (searchMember is IFieldSymbol searchField)
                {
                    if (searchField.Name == "NextInChain" || searchField.Name == "Chain")
                        return true;
                }
            }

            return false;
        }

        // Really garbage but for now should suffice.
        private bool IsArrayCounter(ImmutableArray<ISymbol> members, IFieldSymbol field)
        {
            if (!field.Name.Contains("Count"))
                return false;
            foreach (var searchMember in members)
            {
                if (searchMember is IFieldSymbol searchField)
                {
                    if (searchField.Name == $"{field.Name.Replace("Count", "")}")
                    {
                        return true;
                    }

                    // TODO: Should probably only replace last, but it'll do for now.
                    if (searchField.Name == $"{field.Name.Replace("Count", "")}s")
                    {
                        return true;
                    }

                    if (searchField.Name == $"{field.Name.Replace("Count", "").TrimEnd('y')}ies")
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsArrayField(ImmutableArray<ISymbol> members, IFieldSymbol field, out string countFieldName)
        {
            foreach (var searchMember in members)
            {
                if (searchMember is IFieldSymbol searchField)
                {
                    if (searchField.Name == field.Name + "Count")
                    {
                        countFieldName = field.Name + "Count";
                        return true;
                    }

                    if (searchField.Name == field.Name.TrimEnd('s') + "Count")
                    {
                        countFieldName = field.Name.TrimEnd('s') + "Count";
                        return true;
                    }

                    if (searchField.Name == field.Name.Replace("ies", "y") + "Count")
                    {
                        countFieldName = field.Name.Replace("ies", "y") + "Count";
                        return true;
                    }
                }
            }

            countFieldName = "";
            return false;
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Do Nothing.
        }
    }
}