using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Rover656.SilkyWebGPU.SourceGenerators
{
    /// <summary>
    /// Source generator for generating friendly struct wrappers.
    /// </summary>
    [Generator]
    public class WGPUStructSourceGenerator : ISourceGenerator
    {
        private static readonly string[] Structs =
        {
            "AdapterProperties", "BindGroupLayoutDescriptor", "BufferBindingLayout",
            "BufferDescriptor", "CommandBufferDescriptor", "CommandEncoderDescriptor", "InstanceDescriptor",
            "PipelineLayoutDescriptor", "QuerySetDescriptor", "RenderBundleDescriptor", "RenderBundleEncoderDescriptor",
            "RequestAdapterOptions", "SamplerDescriptor", "SurfaceDescriptor", "SwapChainDescriptor",
            "TextureViewDescriptor", "BindGroupDescriptor", "ComputePassDescriptor", "ProgrammableStageDescriptor",
            "ShaderModuleDescriptor", "TextureDescriptor", "ComputePipelineDescriptor",
            "DeviceDescriptor", "RenderPassDescriptor", "RenderPipelineDescriptor",

            // Extensions
            "Extensions.WGPU.AdapterExtras",
            "Extensions.WGPU.DeviceExtras", "Extensions.WGPU.InstanceExtras",
            "Extensions.WGPU.PipelineLayoutExtras", "Extensions.WGPU.ShaderModuleGLSLDescriptor",
            "Extensions.WGPU.SupportedLimitsExtras", "Extensions.WGPU.SwapChainDescriptorExtras"
        };

        public void Execute(GeneratorExecutionContext context)
        {
            foreach (var structName in Structs)
            {
                var structSymbol = context.Compilation.GetTypeByMetadataName($"{Constants.WebGpuNS}.{structName}");
                if (structSymbol == null)
                    continue;

                var structFriendlyName = structName.Split('.').Last();
                // var structExtraNamespace = "";
                // if (structName.Contains("."))
                // {
                //     structExtraNamespace = "." + structName.Remove(
                //         structName.Length - structFriendlyName.Length - 1,
                //         structFriendlyName.Length + 1);
                // }

                var outputWriter = new StringBuilder($@"// <auto-generated/>

using {Constants.ExtensionNS};
using {Constants.ExtensionNS}.Chain;

using Silk.NET.WebGPU;
using Silk.NET.WebGPU.Extensions.WGPU;

namespace {Constants.ExtensionNS};

");

                outputWriter.Append($@"
public class Managed{structFriendlyName} : ChainedStruct<{Constants.WebGpuNS}.{structName}>
{{
");

                // Get fields
                foreach (var member in structSymbol.GetMembers())
                {
                    if (member is IFieldSymbol field)
                    {
                        // Skip anything to do with the chain.
                        if (field.Name == "Chain" || field.Name == "NextInChain")
                            continue;

                        if (field.Type.Kind != SymbolKind.PointerType)
                        {
                            outputWriter.Append($@"
     public {field.Type} {field.Name}
     {{
         get => _native.{field.Name};
         set => _native.{field.Name} = value;
     }}
 ");
                        }
                        else
                        {
                            var pointerType = field.Type as IPointerTypeSymbol;

                            if (WGPUExtensionSourceGenerator.Objects.Contains(pointerType.PointedAtType.Name))
                            {
                                // We ball
                                outputWriter.Append($@"
     public unsafe {Constants.NativePtrType}<{pointerType.PointedAtType}> {field.Name}
     {{
         /*get => _native.{field.Name};*/ // TODO: How do we do...
         set => _native.{field.Name} = value;
     }}
 ");
                            }
                            else
                            {
                                outputWriter.AppendLine($"    // {field.Type} : {field.Name}");
                                outputWriter.AppendLine("    // Not supported yet.");
                            }
                        }
                    }
                }

                outputWriter.AppendLine("}");

                context.AddSource($"{structFriendlyName}.generated.cs", outputWriter.ToString());
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Do Nothing.
        }
    }
}