using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

// Funky namespace because we're going to share this file.
namespace Rover656.SilkyWebGPU.BaseSourceGenerator;

internal static class GeneratorConstants {
    public const string NativePtrType = "WebGPUPtr";
    public const string NativeChainableArrayType = "NativeArray";
    public const string NativePointerArrayType = "NativePtrArray";
    public const string ChainedStructBaseClass = "ChainedStruct";
    public const string WrappedStructBaseClass = "WrappedStruct";
    public const string ExtensionNS = "Rover656.SilkyWebGPU";
    
    public static readonly string[] ClassObjects =
    {
        "Adapter", "BindGroup", "BindGroupLayout", "Buffer", "CommandBuffer", "CommandEncoder",
        "ComputePassEncoder", "ComputePipeline", "Device", "Instance", "PipelineLayout", "QuerySet", "Queue",
        "RenderBundle", "RenderBundleEncoder", "RenderPassEncoder", "RenderPipeline", "Sampler", "ShaderModule",
        "Surface", "SwapChain", "Texture", "TextureView"
    };
    
    public const string WebGpuNS = "Silk.NET.WebGPU";
    public const string WgpuNS = $"{WebGpuNS}.Extensions.WGPU";
    public const string DawnNS = $"{WebGpuNS}.Extensions.WGPU";
}

public class BaseExtensionMethodGenerator : ISourceGenerator
{
    private static string _referenceClass;
    private static string _extensionNs;
    private static string _apiHandle;

    public BaseExtensionMethodGenerator(string referenceClass, string extensionNamespace, string apiHandle)
    {
        _referenceClass = referenceClass;
        _extensionNs = extensionNamespace;
        _apiHandle = apiHandle;
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Get reference class
        var referenceClass = context.Compilation.GetTypeByMetadataName(_referenceClass);
            
        // Return if its not found
        if (referenceClass == null)
            return;
            
        // Collect methods for generation
        var methodsDefinitions = new List<MethodDefinition>();
        foreach (var classMember in referenceClass.GetMembers())
        {
            if (classMember is IMethodSymbol classMethod)
            {
                ProcessMethod(classMethod, ref methodsDefinitions);
            }
        }

        // Write output source
        var outputWriter = new StringBuilder($@"// <auto-generated/>
using {GeneratorConstants.ExtensionNS};
using {GeneratorConstants.ExtensionNS}.Native;
using {GeneratorConstants.ExtensionNS}.Native.Chain;

using Silk.NET.WebGPU;
using Silk.NET.WebGPU.Extensions.WGPU;

namespace {_extensionNs};

public static partial class MethodExtensions
{{");
            
        foreach (var method in methodsDefinitions)
        {
            outputWriter.AppendLine($@"
    public static unsafe {method.ReturnType} {method.Name}{method.TypeParameterDecl}(this {GeneratorConstants.NativePtrType}<{method.Owner.Type}> {method.Owner.ParameterName}{method.ParameterDecl}) {method.ConstraintDecl}
    {{
        if ({method.Owner.ParameterName}.IsNull()) throw new NullReferenceException();
        {method.GetMethodCall(_apiHandle)}
    }}");
        }
            
        outputWriter.Append('}');

        context.AddSource($"MethodExtensions.generated.cs", outputWriter.ToString());
            
    }

    private void ProcessMethod(IMethodSymbol classMethod, ref List<MethodDefinition> methodDefinitions)
    {
        // Ignore parameterless methods
        if (classMethod.Parameters.Length <= 0)
            return;
            
        // Get the owner of this method
        if (!GetObjectOwner(classMethod, out var ownerDefinition))
            return;

        // Check for method exclusion.
        if (ExcludeMethod(classMethod))
            return;
            
        // Collect basic information (that does not change between variants)
        var baseDefinition = new MethodDefinition
        {
            ReturnType = new MethodReturnType(classMethod),
            Owner = ownerDefinition,
            Name = classMethod.Name.Replace(ownerDefinition.Name, ""),
            OriginalName = classMethod.Name,
            Parameters = DefineParameters(classMethod),
            TypeParameters = DefineTypeParameters(classMethod),
        };
            
        // Add default extension method definition
        methodDefinitions.Add(baseDefinition);
            
        // TODO: Generate variants without ref T0's.
    }

    private static bool GetObjectOwner(IMethodSymbol method, out ManagedOwnerDefinition ownerDefinition)
    {
        // Default
        ownerDefinition = default;
            
        // We only expand methods that are owned by object's we recognize
        var objectParameter = method.Parameters[0];
        if (objectParameter.Type is not IPointerTypeSymbol objectPointer)
            return false;
            
        // Get object type
        var objectType = objectPointer.PointedAtType;
            
        // If we don't recognize this type, ignore it
        if (!GeneratorConstants.ClassObjects.Contains(objectType.Name))
            return false;
            
        // We have a match
        ownerDefinition = new ManagedOwnerDefinition
        {
            Name = objectType.Name,
            Type = objectType.ToString(),
            ParameterName = objectParameter.Name,
        };
        return true;
    }

    private static List<MethodParameterDefinition> DefineParameters(IMethodSymbol method)
    {
        var parameters = new List<MethodParameterDefinition>(method.Parameters.Length - 1);
        for (var i = 1; i < method.Parameters.Length; i++)
        {
            parameters.Add(new MethodParameterDefinition(method.Parameters[i]));
        }
        return parameters;
    }

    private static List<TypeParameterDefinition> DefineTypeParameters(IMethodSymbol method)
    {
        var parameters = new List<TypeParameterDefinition>(method.TypeParameters.Length);
        for (var i = 0; i < method.TypeParameters.Length; i++)
        {
            parameters.Add(new TypeParameterDefinition(method.TypeParameters[i]));
        }
        return parameters;
    }

    private static bool ExcludeMethod(IMethodSymbol method)
    {
        for (var i = 1; i < method.Parameters.Length; i++)
        {
            // Get parameter
            var parameter = method.Parameters[i];
                
            // We disallow ref pointers.
            if (parameter.Type is IPointerTypeSymbol pointerParameter)
            {
                if (parameter.RefKind == RefKind.Ref)
                {
                    // We don't deal with ref pointers, these are arrays and handled another way.
                    return true;
                }

                if (pointerParameter.PointedAtType is IPointerTypeSymbol arrayType)
                {
                    // TODO: These arrays need the count parameter removed and redirected too.
                    if (!GeneratorConstants.ClassObjects.Contains(arrayType.PointedAtType.Name))
                    {
                        // We don't deal with unknown array types.
                        return true;
                    }
                }
            }
        }

        return false;
    }

    public void Initialize(GeneratorInitializationContext context)
    {
    }
}

internal struct MethodReturnType
{
    public string Type;
    public bool ClassObject;

    public MethodReturnType(IMethodSymbol method)
    {
        if (method.ReturnType is IPointerTypeSymbol pointer && GeneratorConstants.ClassObjects.Contains(pointer.PointedAtType.Name))
        {
            ClassObject = true;
            Type = pointer.PointedAtType.ToString();
        }
        else
        {
            ClassObject = false;
            Type = method.ReturnType.ToString();
        }
    }

    public override string ToString() => ClassObject ? $"{GeneratorConstants.NativePtrType}<{Type}>" : Type;
}
    
internal struct MethodParameterDefinition
{
    public string Type;
    public string Name;
    public string ParameterPrefix;
    public string ArgumentPrefix;

    public MethodParameterDefinition(IParameterSymbol parameter)
    {
        Name = parameter.Name;
        ParameterPrefix = parameter.RefKind switch
        {
            RefKind.Ref => "ref",
            RefKind.Out => "out",
            RefKind.In => "in",
            _ => ""
        };
        ArgumentPrefix = parameter.RefKind switch
        {
            RefKind.Ref => "ref",
            RefKind.Out => "out",
            _ => ""
        };

        if (parameter.Type is IPointerTypeSymbol pointerType)
        {
            if (pointerType.PointedAtType is IPointerTypeSymbol arrayType)
            {
                if (GeneratorConstants.ClassObjects.Contains(arrayType.PointedAtType.Name))
                {
                    Type = $"{GeneratorConstants.NativePointerArrayType}<{arrayType.PointedAtType}>";
                }
                else
                {
                    Type = $"{GeneratorConstants.NativeChainableArrayType}<{arrayType.PointedAtType}>";
                }
            }
            else if (GeneratorConstants.ClassObjects.Contains(pointerType.PointedAtType.Name))
            {
                Type = $"{GeneratorConstants.NativePtrType}<{pointerType.PointedAtType}>";
            }
            else
            {
                Type = parameter.Type.ToString();
            }
        }
        else
        {
            Type = parameter.Type.ToString();
        }
    }
}
    
internal struct ManagedOwnerDefinition
{
    public string Name;
    public string Type;
    public string ParameterName;
}

internal struct TypeParameterDefinition
{
    public string Name;
    public List<string> Constraints;

    public TypeParameterDefinition(ITypeParameterSymbol typeParameter)
    {
        Name = typeParameter.Name;
        Constraints = new List<string>();
            
        // Add type parameter constraints
        if (typeParameter.HasUnmanagedTypeConstraint) Constraints.Add("unmanaged");
        if (typeParameter.HasConstructorConstraint) Constraints.Add("new()");
        if (typeParameter.HasNotNullConstraint) Constraints.Add("notnull");
        if (typeParameter.HasReferenceTypeConstraint) Constraints.Add("class");
        if (typeParameter.HasValueTypeConstraint && !typeParameter.HasUnmanagedTypeConstraint)
            Constraints.Add("struct");
        foreach (var constraintType in typeParameter.ConstraintTypes) Constraints.Add(constraintType.ToString());
    }

    public string ConstraintDecl => $"where {Name} : {string.Join(", ", Constraints)}";
}
    
internal struct MethodDefinition
{
    public MethodReturnType ReturnType;
    public ManagedOwnerDefinition Owner;
    public string Name;
    public string OriginalName;
    public List<MethodParameterDefinition> Parameters;
    public List<TypeParameterDefinition> TypeParameters;
        
    public string ArgumentParameterDecl
    {
        get
        {
            if (Parameters.Count <= 0)
                return "";

            var builder = new StringBuilder(", ");
            foreach (var parameter in Parameters)
            {
                if (!string.IsNullOrEmpty(parameter.ArgumentPrefix))
                    builder.Append($"{parameter.ArgumentPrefix} ");
                builder.Append($"{parameter.Name}, ");
            }

            return builder.ToString().TrimEnd(',', ' ');
        }
    }

    public string ParameterDecl
    {
        get
        {
            if (Parameters.Count <= 0)
                return "";

            var builder = new StringBuilder(", ");
            foreach (var parameter in Parameters)
            {
                if (!string.IsNullOrEmpty(parameter.ParameterPrefix))
                    builder.Append($"{parameter.ParameterPrefix} ");
                builder.Append($"{parameter.Type} {parameter.Name}, ");
            }
            return builder.ToString().TrimEnd(',', ' ');
        }
    }

    public string GetMethodCall(string apiHandle)
    {
        var builder = new StringBuilder(ReturnType.Type == "void" ? "" : "return ");

        if (ReturnType.ClassObject) builder.Append($"{ReturnType}.MakeStrong(");

        builder.Append($"{apiHandle}.{OriginalName}({Owner.ParameterName}{ArgumentParameterDecl})");

        if (ReturnType.ClassObject) builder.Append(')');
        builder.Append(';');

        return builder.ToString();
    }

    public string TypeParameterDecl => TypeParameters.Count <= 0 ? "" : $"<{string.Join(", ", TypeParameters.Select(e => e.Name))}>";
    public string ConstraintDecl => TypeParameters.Count <= 0 ? "" : string.Join(Environment.NewLine, TypeParameters.Select(e => e.ConstraintDecl));
}